<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>

    <h1>TITULO</h1>
    <p>PARAGRAFO</p>
    <div>DADOS</div>

    <script>
        console.log(this); // é window

        // arrow function agora!
        let exibeConteudo = () =>  {
            console.log(this);
            alert(this.textContent);
        };

        $ = document.querySelector.bind(document);

        $('h1').addEventListener('click', exibeConteudo);

        $('p').addEventListener('click', exibeConteudo);

        $('div').addEventListener('click', exibeConteudo);

    </script>
</body>
</html>

<!--Um teste demonstra que nosso código deixa de funcionar. Primeiro, independente do elemento que eu clique, o this que é impresso no console
    é window e não aquele elemento do DOM. Segundo, como this é window e ele não possui a propriedade textContent, é exibido undefined para o
    usuário. Esse problema serve para demonstrar que uma arrow function vai além de uma sintaxe mais enxuta para declararmos funções.

    Diferente de uma função, que possui um this dinâmico, uma arrow function possui um this estático, ou seja, que nunca muda e que é
    determinado no momento em que é declarado! Veja que quando declararmos nossa arrow function, ela vai considerar o this do local onde é
    declarada. Sendo assim, como o this dentro da tag <script> é window, ela adotará window.

    Resumindo:

    O this de uma função é dinâmico, isto é, seu valor é determinado no momento em que a função é chamada. Como o this é dinâmico,
    é possível usar artifícios da linguagem, como a API Reflect, para alterá-lo se assim desejarmos.

    O this de uma arrow function é léxico, isto é, seu valor é determinado no local onde a arrow function for definida,
    ela não cria um novo this. O this de uma arrow function não pode ser alterado, mesmo se usarmos recursos da linguagem, como a API Reflect.
-->